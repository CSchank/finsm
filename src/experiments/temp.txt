module ParserKleene exposing (char, chars, charsHelper, empty, endInput, escape, flip, ident, initLast, initLastHelper, kleeneOp, oldParser, paren, parseKleene, reserved, topParser)

import Debug exposing (todo)
import Kleene exposing (..)
import List exposing (..)
import Parser exposing (..)
import Set exposing (..)
import Tuple exposing (first, mapBoth, mapFirst, second)


parseKleene : String -> Kleene String
parseKleene =
    run topParser >> Result.withDefault Empty


topParser : Parser (Kleene String)
topParser =
    succeed (|>)
        |= oneOf [ ident, paren, chars ]
        |= oneOf
            [ succeed (\expr -> flip Plus expr)
                |. token "|"
                |= lazy (\_ -> topParser)
            , succeed (\expr -> flip mul expr)
                |. token "^"
                |= lazy (\_ -> topParser)
            , succeed identity |. end
            , succeed (\expr -> flip mul expr)
                |= lazy (\_ -> topParser)
            ]


paren : Parser (Kleene String)
paren =
    succeed (|>)
        |. token "("
        |= lazy (\_ -> topParser)
        |. token ")"
        |= oneOf
            [ succeed Star
                |. token "*"
            , succeed identity
            ]


chars : Parser (Kleene String)
chars =
    loop "" charsHelper


charsHelper : String -> Parser (Step String (Kleene String))
charsHelper str =
    oneOf
        [ succeed (\c -> Loop (str ++ c))
            |= oneOf [ char, escape ]
        , succeed (\rest -> Done <| abStarc str rest)
            |. starchar
            |= lazy (\_ -> chars)
        , case str of
            "" -> succeed (Done <| Id)
            _  -> succeed (Done <| Alpha str) 
        ]

abStarc : String -> Kleene String -> Kleene String
abStarc prev rest =
    let
        abStar = (initLast prev |> mapBoth Alpha (Alpha >> Star) |> (\( x, y ) -> mul x y))
    in
        mul abStar rest


char : Parser String
char =
    getChompedString <| chompIf <| \x -> Char.isAlphaNum x


escape : Parser String
escape =
    succeed identity
        |. chompIf (\c -> c == '\\')
        |= getChompedString (chompIf (\c -> Set.member c special))


ident : Parser (Kleene String)
ident =
    succeed Id
        |. (getChompedString <| chompIf (\c -> c == 'ε'))

starchar : Parser String
starchar = getChompedString <| chompIf (\c -> c == '*')

empty : Parser (Kleene String)
empty =
    succeed Empty


endInput : Parser (Kleene String)
endInput =
    succeed Id |. end



-- split a string into its init and last


initLast : String -> ( String, String )
initLast s =
    initLastHelper (String.toList s) |> mapBoth String.fromList String.fromList


initLastHelper : List Char -> ( List Char, List Char )
initLastHelper lc =
    case lc of
        [] ->
            ( [], [] )

        x :: [] ->
            ( [], [ x ] )

        x :: xs ->
            mapFirst ((::) x) <| initLastHelper xs


flip : (a -> b -> c) -> b -> a -> c
flip f b a =
    f a b


reserved =
    [ '|', '*', 'ε', '(', ')', '\\' ]



-----
-- Old parser definitions live here. They can be removed
-- if the new parser is sufficiently as good.
-----


oldParser : Parser (Kleene String)
oldParser =
    oneOf
        [ backtrackable <| lazy (\_ -> kleeneOp oldParser)
        , ident
        , chars
        ]


kleeneOp : Parser (Kleene String) -> Parser (Kleene String)
kleeneOp rec =
    succeed
        (\a ( op, b ) ->
            case op of
                "|" ->
                    Plus a b

                "^" ->
                    Mul a b

                "*" ->
                    Star a

                _ ->
                    Empty
        )
        |. symbol "("
        |= lazy (\_ -> rec)
        |= oneOf
            [ succeed (\op -> ( op, Empty ))
                |. symbol ")"
                |= (getChompedString <| symbol "*")
            , succeed (\op b -> ( op, b ))
                |= (getChompedString <| oneOf [ symbol "|", symbol "^" ])
                |= lazy (\_ -> rec)
                |. symbol ")"
            ]
